// Docker Compose override generation
// Auto-generates per-worktree docker-compose.override.yml files

use crate::config::DockerConfig;
use crate::errors::Result;
use std::collections::HashMap;
use std::fs;
use std::path::Path;

/// Generates docker-compose.override.yml files for worktrees
pub struct ComposeGenerator<'a> {
    config: &'a DockerConfig,
    state_dir: &'a Path,
}

impl<'a> ComposeGenerator<'a> {
    /// Create a new compose generator
    pub fn new(config: &'a DockerConfig, state_dir: &'a Path) -> Self {
        Self { config, state_dir }
    }

    /// Generate docker-compose.override.yml content for a worktree
    pub fn generate(
        &self,
        worktree_name: &str,
        _worktree_path: &Path,
        ports: &HashMap<String, u16>,
    ) -> Result<String> {
        let mut output = String::new();

        // Header
        output.push_str("# Auto-generated by hn\n");
        output.push_str(&format!("# Worktree: {}\n", worktree_name));
        output.push_str("# Do not edit manually - regenerate with: hn docker regenerate\n\n");

        // Services section
        output.push_str("services:\n");

        // Generate service overrides based on allocated ports
        for (service_name, port) in ports {
            output.push_str(&format!("  {}:\n", service_name));

            // Port mappings
            output.push_str("    ports:\n");
            output.push_str(&format!(
                "      - \"{}:{}\"",
                port,
                self.get_internal_port(service_name)
            ));
            output.push('\n');

            // Environment variables with substitutions
            if !self.config.env.is_empty() {
                output.push_str("    environment:\n");
                for (key, value) in &self.config.env {
                    let substituted = self.substitute_variables(value, worktree_name, ports);
                    output.push_str(&format!("      {}: \"{}\"\n", key, substituted));
                }
            }
        }

        // Volumes section
        if !self.config.shared.volumes.is_empty() || !self.config.isolated.volumes.is_empty() {
            output.push_str("\nvolumes:\n");

            // Shared volumes (external)
            for volume in &self.config.shared.volumes {
                output.push_str(&format!("  {}:\n", volume));
                output.push_str("    external: true\n");
            }

            // Isolated volumes (worktree-specific)
            for volume in &self.config.isolated.volumes {
                let volume_name = format!("{}-{}", worktree_name, volume);
                output.push_str(&format!("  {}:\n", volume_name));
                output.push_str(&format!("    name: {}\n", volume_name));
            }
        }

        // Networks section
        if !self.config.shared.networks.is_empty() {
            output.push_str("\nnetworks:\n");
            for network in &self.config.shared.networks {
                output.push_str(&format!("  {}:\n", network));
                output.push_str("    external: true\n");
            }
        }

        Ok(output)
    }

    /// Save docker-compose.override.yml to disk
    pub fn save(
        &self,
        worktree_name: &str,
        worktree_path: &Path,
        ports: &HashMap<String, u16>,
    ) -> Result<()> {
        let content = self.generate(worktree_name, worktree_path, ports)?;

        // Create worktree state directory
        let worktree_state = self.state_dir.join(worktree_name);
        fs::create_dir_all(&worktree_state)?;

        // Write override file
        let override_path = worktree_state.join("docker-compose.override.yml");
        fs::write(&override_path, content)?;

        Ok(())
    }

    /// Delete override file for a worktree
    pub fn delete(&self, worktree_name: &str) -> Result<()> {
        let override_path = self
            .state_dir
            .join(worktree_name)
            .join("docker-compose.override.yml");

        if override_path.exists() {
            fs::remove_file(&override_path)?;
        }

        Ok(())
    }

    /// Substitute template variables in strings
    fn substitute_variables(
        &self,
        template: &str,
        worktree_name: &str,
        ports: &HashMap<String, u16>,
    ) -> String {
        let mut result = template.to_string();

        // Replace {{worktree_name}}
        result = result.replace("{{worktree_name}}", worktree_name);

        // Replace {{port.service}}
        for (service, port) in ports {
            let placeholder = format!("{{{{port.{}}}}}", service);
            result = result.replace(&placeholder, &port.to_string());
        }

        result
    }

    /// Get internal port for a service (default mappings)
    fn get_internal_port(&self, service_name: &str) -> u16 {
        match service_name {
            "app" => 3000,
            "postgres" => 5432,
            "redis" => 6379,
            "mysql" => 3306,
            "mongodb" => 27017,
            _ => 8080,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_substitute_variables() {
        let temp_dir = TempDir::new().unwrap();
        let config = DockerConfig::default();
        let generator = ComposeGenerator::new(&config, temp_dir.path());

        let mut ports = HashMap::new();
        ports.insert("app".to_string(), 3000);
        ports.insert("postgres".to_string(), 5432);

        let template = "postgres://localhost:{{port.postgres}}/db_{{worktree_name}}";
        let result = generator.substitute_variables(template, "feature-x", &ports);

        assert_eq!(result, "postgres://localhost:5432/db_feature-x");
    }

    #[test]
    fn test_get_internal_port() {
        let temp_dir = TempDir::new().unwrap();
        let config = DockerConfig::default();
        let generator = ComposeGenerator::new(&config, temp_dir.path());

        assert_eq!(generator.get_internal_port("app"), 3000);
        assert_eq!(generator.get_internal_port("postgres"), 5432);
        assert_eq!(generator.get_internal_port("redis"), 6379);
        assert_eq!(generator.get_internal_port("unknown"), 8080);
    }
}
