use hannahanna::config::{Config, DockerConfig};
use hannahanna::docker::compose::ComposeGenerator;
use hannahanna::docker::ports::PortAllocator;
use std::collections::HashMap;
use std::fs;
use tempfile::TempDir;

#[test]
fn test_generate_compose_override() {
    // TDD RED: ComposeGenerator doesn't exist yet!
    // Goal: Generate valid docker-compose.override.yml with correct structure

    let temp_dir = TempDir::new().unwrap();
    let state_dir = temp_dir.path().join(".wt-state");
    let worktree_dir = temp_dir.path().join("worktrees").join("feature-x");
    std::fs::create_dir_all(&worktree_dir).unwrap();
    std::fs::create_dir_all(&state_dir).unwrap();

    // Allocate ports first
    let mut allocator = PortAllocator::new(&state_dir).unwrap();
    let ports = allocator.allocate("feature-x", &["app", "postgres"]).unwrap();

    // Create generator with config
    let config = DockerConfig::default();
    let generator = ComposeGenerator::new(&config, &state_dir);

    // Generate override
    let override_content = generator
        .generate("feature-x", &worktree_dir, &ports)
        .unwrap();

    // Verify it's valid YAML
    assert!(override_content.contains("services:"));
    assert!(override_content.contains("# Auto-generated by hn"));

    // Parse as YAML to ensure validity
    let parsed: serde_yml::Value = serde_yml::from_str(&override_content).unwrap();
    assert!(parsed.get("services").is_some());
}

#[test]
fn test_template_substitution() {
    // TDD RED: Test that variables are correctly replaced
    // Variables: {{worktree_name}}, {{port.app}}, {{port.postgres}}

    let temp_dir = TempDir::new().unwrap();
    let state_dir = temp_dir.path().join(".wt-state");
    let worktree_dir = temp_dir.path().join("worktrees").join("feature-auth");
    std::fs::create_dir_all(&worktree_dir).unwrap();
    std::fs::create_dir_all(&state_dir).unwrap();

    let mut allocator = PortAllocator::new(&state_dir).unwrap();
    let ports = allocator.allocate("feature-auth", &["app", "postgres"]).unwrap();

    // Config with environment variable templates
    let mut config = DockerConfig::default();
    config
        .env
        .insert("PORT".to_string(), "{{port.app}}".to_string());
    config.env.insert(
        "DATABASE_URL".to_string(),
        "postgres://localhost:{{port.postgres}}/db_{{worktree_name}}".to_string(),
    );

    let generator = ComposeGenerator::new(&config, &state_dir);
    let override_content = generator
        .generate("feature-auth", &worktree_dir, &ports)
        .unwrap();

    // Verify substitutions
    assert!(override_content.contains("3000")); // port.app
    assert!(override_content.contains("5432")); // port.postgres
    assert!(override_content.contains("feature-auth")); // worktree_name
    assert!(override_content.contains("db_feature-auth")); // in DATABASE_URL

    // Should NOT contain template markers
    assert!(!override_content.contains("{{port.app}}"));
    assert!(!override_content.contains("{{port.postgres}}"));
    assert!(!override_content.contains("{{worktree_name}}"));
}

#[test]
fn test_shared_volumes() {
    // TDD RED: Test shared volumes get external: true
    // Config: postgres-data shared
    // Verify: external: true, correct name

    let temp_dir = TempDir::new().unwrap();
    let state_dir = temp_dir.path().join(".wt-state");
    let worktree_dir = temp_dir.path().join("worktrees").join("feature-db");
    std::fs::create_dir_all(&worktree_dir).unwrap();
    std::fs::create_dir_all(&state_dir).unwrap();

    let mut allocator = PortAllocator::new(&state_dir).unwrap();
    let ports = allocator.allocate("feature-db", &["app"]).unwrap();

    let mut config = DockerConfig::default();
    config.shared.volumes = vec!["postgres-data".to_string()];

    let generator = ComposeGenerator::new(&config, &state_dir);
    let override_content = generator
        .generate("feature-db", &worktree_dir, &ports)
        .unwrap();

    // Parse and verify
    let parsed: serde_yml::Value = serde_yml::from_str(&override_content).unwrap();
    if let Some(volumes) = parsed.get("volumes") {
        if let Some(pg_data) = volumes.get("postgres-data") {
            assert_eq!(pg_data.get("external"), Some(&serde_yml::Value::Bool(true)));
        } else {
            panic!("postgres-data volume not found");
        }
    }
}

#[test]
fn test_isolated_volumes() {
    // TDD RED: Test isolated volumes get worktree-specific names
    // Config: app-cache isolated
    // Verify: worktree-specific name (e.g., feature-cache_app-cache)

    let temp_dir = TempDir::new().unwrap();
    let state_dir = temp_dir.path().join(".wt-state");
    let worktree_dir = temp_dir.path().join("worktrees").join("feature-cache");
    std::fs::create_dir_all(&worktree_dir).unwrap();
    std::fs::create_dir_all(&state_dir).unwrap();

    let mut allocator = PortAllocator::new(&state_dir).unwrap();
    let ports = allocator.allocate("feature-cache", &["app"]).unwrap();

    let mut config = DockerConfig::default();
    config.isolated.volumes = vec!["app-cache".to_string(), "logs".to_string()];

    let generator = ComposeGenerator::new(&config, &state_dir);
    let override_content = generator
        .generate("feature-cache", &worktree_dir, &ports)
        .unwrap();

    // Verify isolated volumes have worktree-specific names
    assert!(override_content.contains("feature-cache_app-cache") || override_content.contains("feature-cache-app-cache"));
    assert!(override_content.contains("feature-cache_logs") || override_content.contains("feature-cache-logs"));
}

#[test]
fn test_save_override_to_disk() {
    // TDD RED: Test that override is saved to correct location
    // Location: .wt-state/<name>/docker-compose.override.yml

    let temp_dir = TempDir::new().unwrap();
    let state_dir = temp_dir.path().join(".wt-state");
    let worktree_dir = temp_dir.path().join("worktrees").join("feature-save");
    std::fs::create_dir_all(&worktree_dir).unwrap();
    std::fs::create_dir_all(&state_dir).unwrap();

    let mut allocator = PortAllocator::new(&state_dir).unwrap();
    let ports = allocator.allocate("feature-save", &["app"]).unwrap();

    let config = DockerConfig::default();
    let generator = ComposeGenerator::new(&config, &state_dir);

    // Save to disk
    generator
        .save("feature-save", &worktree_dir, &ports)
        .unwrap();

    // Verify file exists
    let override_path = state_dir
        .join("feature-save")
        .join("docker-compose.override.yml");
    assert!(override_path.exists(), "Override file should exist");

    // Verify content is valid YAML
    let content = fs::read_to_string(&override_path).unwrap();
    let parsed: serde_yml::Value = serde_yml::from_str(&content).unwrap();
    assert!(parsed.get("services").is_some());
}

#[test]
fn test_port_mappings() {
    // TDD RED: Test that port mappings are correct
    // Format: "{{port.service}}:internal_port"

    let temp_dir = TempDir::new().unwrap();
    let state_dir = temp_dir.path().join(".wt-state");
    let worktree_dir = temp_dir.path().join("worktrees").join("feature-ports");
    std::fs::create_dir_all(&worktree_dir).unwrap();
    std::fs::create_dir_all(&state_dir).unwrap();

    let mut allocator = PortAllocator::new(&state_dir).unwrap();
    let ports = allocator
        .allocate("feature-ports", &["app", "postgres", "redis"])
        .unwrap();

    let config = DockerConfig::default();
    let generator = ComposeGenerator::new(&config, &state_dir);
    let override_content = generator
        .generate("feature-ports", &worktree_dir, &ports)
        .unwrap();

    // Verify port mappings are present
    let app_port = ports.get("app").unwrap();
    let pg_port = ports.get("postgres").unwrap();
    let redis_port = ports.get("redis").unwrap();

    // Should contain port mappings like "3000:3000" or similar
    assert!(override_content.contains(&format!("\"{}:", app_port)));
    assert!(override_content.contains(&format!("\"{}:", pg_port)));
    assert!(override_content.contains(&format!("\"{}:", redis_port)));
}
